'''
Databases doesn't support very large numbers, so numbers are stored as a string of binary characters, '0' and '1' . Accidentally, a ! was entered at some positions and it is unknown whether they should be '0' or '1' .
The string of incorrect data is made up of the characters '0' , '1' and ! where '!' is the character that got entered incorrectly. '!' can be replaced with either '0' or '1' . Due to some internal faults, some errors are generated every time '0' and '1' occur together as '01' or '10' in any subsequence of the string. It is observed that the number of errors a subsequence '01' generates is x , while a subsequence '10' generates y errors.
Determine the minimum total errors generated? Since the answer can be very large, return it modulo 10 9 +7.

Function Description
Complete the function minTotalErrors in the editor.
minTotalErrors has the following parameters:
String errorString : a string representing the binary data with errors
int x : the number of errors generated by the subsequence '01'
int y : the number of errors generated by the subsequence '10'

Returns
int: the minimum total errors generated, modulo (10 9 +7)

Example 1 :
Input: errorString = "101!1", x = 2, y = 3
Output: 9 
Explanation:
Given string errorString = "101!1", x = 2, y = 3,
If the '!' at index 3 is replaced with '0', the string is "10101". The number of times the subsequence 01 occurs is 3 at indices (1, 2), (1, 4), and (3, 4). The number of times the subsequence 10 occurs is also 3, indices (0, 1), (0, 3) and (2, 3). The number of errors is 3 * x + 3 * y = 6 + 9 = 15.
If the '!' is replaced with '1', the string is "10111". The subsequence 01 occurs 3 times and10 occurs 1 time. The number of errors is 3 * x + y = 9.
'''
def minTotalErrors(errorString, x, y):
    MOD = 10**9 + 7
    n = len(errorString)
    
    # dp0[i]: Minimum errors if errorString[i] is '0'
    # dp1[i]: Minimum errors if errorString[i] is '1'
    dp0 = [0] * n
    dp1 = [0] * n
    
    # Initialize the first character
    if errorString[0] == '0':
        dp0[0] = 0
        dp1[0] = float('inf')
    elif errorString[0] == '1':
        dp0[0] = float('inf')
        dp1[0] = 0
    else:  # errorString[0] == '!'
        dp0[0] = 0
        dp1[0] = 0
    
    for i in range(1, n):
        if errorString[i] == '0':
            dp0[i] = min(dp0[i-1], dp1[i-1] + y)
            dp1[i] = float('inf')
        elif errorString[i] == '1':
            dp0[i] = float('inf')
            dp1[i] = min(dp1[i-1], dp0[i-1] + x)
        else:  # errorString[i] == '!'
            dp0[i] = min(dp0[i-1], dp1[i-1] + y)
            dp1[i] = min(dp1[i-1], dp0[i-1] + x)
    
    result = min(dp0[-1], dp1[-1])
    return result % MOD

# Example usage
errorString = "101!1"
x = 2
y = 3
print(minTotalErrors(errorString, x, y))  # Output: 9
